<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìºë¦­í„° ì¡°íšŒ & ì¶”ì </title>
    <style>
        body { font-family: Arial, sans-serif; }
        
        /* ì „ì²´ ë ˆì´ì•„ì›ƒ ì„¤ì • */
        .container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            max-width: 1200px;
            margin: auto;
            gap: 20px;
        }

        /* ì™¼ìª½ ìºë¦­í„° ì¡°íšŒ ì˜ì—­ */
        .search-section {
            width: 45%;
        }

        /* ì˜¤ë¥¸ìª½ ì˜ˆì˜ì£¼ì‹œ ëª©ë¡ */
        .tracking-section {
            width: 50%;
        }

        /* ìºë¦­í„° ì¹´ë“œ ìŠ¤íƒ€ì¼ */
        .character-card {
            border: 1px solid #ccc; 
            padding: 10px; 
            margin: 5px; 
            border-radius: 5px;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            width: 100%;
        }

        .character-list {
            display: flex; 
            flex-wrap: wrap; 
            gap: 10px; 
            margin-top: 10px;
        }

        .option-group { margin-top: 5px; }
        .result { margin-top: 10px; font-size: 14px; }
        button { margin-top: 5px; cursor: pointer; }
    </style>
</head>
<body>
    <h2>ìºë¦­í„° ì¡°íšŒ & ì¶”ì </h2>

    <div class="container">
        <!-- ì™¼ìª½: ìºë¦­í„° ê²€ìƒ‰ -->
        <div class="search-section">
            <h3>ìºë¦­í„° ì¡°íšŒ</h3>
            <input type="text" id="characterName" placeholder="ìºë¦­í„°ëª… ì…ë ¥">
            <button onclick="fetchOCID()">ì¡°íšŒ</button>
            <div id="result"></div>
        </div>

        <!-- ì˜¤ë¥¸ìª½: ì˜ˆì˜ì£¼ì‹œí•˜ëŠ” ìºë¦­í„° -->
        <div class="tracking-section">
            <h3>ì˜ˆì˜ì£¼ì‹œí•˜ëŠ” ìºë¦­í„°</h3>
            <input type="text" id="trackingCharacterName" placeholder="ìºë¦­í„°ëª… ì…ë ¥">
            <button onclick="addCharacter()">ë“±ë¡</button>
            <div class="character-list" id="characterList"></div>
        </div>
    </div>

    <script>
        const apiKey = "live_f1df2d99b1e14e205493879cae9b176d6d9dbd4c57ed2f599da1059247fd112fefe8d04e6d233bd35cf2fabdeb93fb0d";
        const servers = ["ì—°", "í•´ëª…", "ì„¸ë¥˜", "ë¬´íœ¼"];
        let trackingIntervals = {};

        async function fetchOCID() {
            const characterName = document.getElementById("characterName").value.trim();
            if (!characterName) {
                alert("ìºë¦­í„°ëª…ì„ ì…ë ¥í•˜ì„¸ìš”.");
                return;
            }

            const resultElement = document.getElementById("result");
            resultElement.innerText = `ğŸ” ${characterName} ê²€ìƒ‰ ì¤‘...`;

            try {
                // ì„œë²„ë³„ë¡œ OCID ìš”ì²­
                const ocidRequests = servers.map(server =>
                    fetch(`https://open.api.nexon.com/baramy/v1/id?character_name=${encodeURIComponent(characterName)}&server_name=${encodeURIComponent(server)}`, {
                        method: "GET",
                        headers: { "accept": "application/json", "x-nxopen-api-key": apiKey }
                    }).then(async response => {
                        if (!response.ok) return null;
                        return response.json();
                    }).catch(error => {
                        console.error(`OCID ìš”ì²­ ì‹¤íŒ¨ (${server}):`, error);
                        return null;
                    })
                );

                const ocidResults = await Promise.all(ocidRequests);
                const validResults = ocidResults.filter(data => data && data.ocid);

                if (validResults.length === 0) {
                    alert("OCIDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ìºë¦­í„°ëª…ì„ í™•ì¸í•˜ì„¸ìš”.");
                    resultElement.innerText = "âŒ ê²€ìƒ‰ ì‹¤íŒ¨: ìºë¦­í„°ëª…ì„ í™•ì¸í•˜ì„¸ìš”.";
                    return;
                }

                // OCIDë³„ë¡œ ìºë¦­í„° ì •ë³´ ì¡°íšŒ
                const characterInfos = await Promise.all(validResults.map(async data => {
                    const { characterData, serverDate } = await fetchCharacterInfo(data.ocid);
                    return characterData ? { ...characterData, ocid: data.ocid, serverDate } : null;
                }));

                // ìœ íš¨í•œ ìºë¦­í„°ë§Œ í•„í„°ë§
                const validCharacters = characterInfos.filter(char => char);
                if (validCharacters.length === 0) {
                    alert("ìºë¦­í„° ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    resultElement.innerText = "âŒ ê²€ìƒ‰ ì‹¤íŒ¨: ìºë¦­í„° ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
                    return;
                }

                // ê°€ì¥ ë†’ì€ ë ˆë²¨ì˜ ìºë¦­í„° ì„ íƒ
                validCharacters.sort((a, b) => a.character_level - b.character_level);
                const highestLevelCharacter = validCharacters.pop();

                if (highestLevelCharacter) {
                    const titleEquipment = await fetchTitleEquipment(highestLevelCharacter.ocid);
                    displayCharacterData(highestLevelCharacter, highestLevelCharacter.serverDate, titleEquipment);
                }
            } catch (error) {
                console.error("OCID ì¡°íšŒ ì˜¤ë¥˜:", error);
                alert("ìºë¦­í„° ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
                resultElement.innerText = "âŒ ê²€ìƒ‰ ì‹¤íŒ¨: ì„œë²„ ì˜¤ë¥˜ ë°œìƒ";
            }
        }


        async function fetchCharacterInfo(ocid) {
            try {
                const response = await fetch(`https://open.api.nexon.com/baramy/v1/character/basic?ocid=${ocid}`, {
                    method: "GET",
                    headers: { "accept": "application/json", "x-nxopen-api-key": apiKey }
                });

                if (!response.ok) {
                    throw new Error(`ìºë¦­í„° ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: ${response.status}`);
                }

                const characterData = await response.json();
                const serverDate = response.headers.get("date"); // ì„œë²„ ì‘ë‹µ ì‹œê°„ ê°€ì ¸ì˜¤ê¸°
                return { characterData, serverDate };
            } catch (error) {
                console.error("ìºë¦­í„° ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜:", error);
                return { characterData: null, serverDate: null };
            }
        }

        async function fetchTitleEquipment(ocid) {
            try {
                const response = await fetch(`https://open.api.nexon.com/baramy/v1/character/title-equipment?ocid=${ocid}`, {
                    method: "GET",
                    headers: { "accept": "application/json", "x-nxopen-api-key": apiKey }
                });

                if (!response.ok) {
                    throw new Error(`ì¹­í˜¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: ${response.status}`);
                }

                return await response.json();
            } catch (error) {
                console.error("ì¹­í˜¸ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜:", error);
                return null;
            }
        }

        function displayCharacterData(data, serverDate, titleEquipment) {
            let formattedKST = "ì„œë²„ ì‘ë‹µ ì‹œê°„ ì—†ìŒ";

            if (serverDate) {
                try {
                    const gmtTime = new Date(serverDate); // ì„œë²„ ì‘ë‹µ ì‹œê°„ (UTC)
                    if (isNaN(gmtTime.getTime())) throw new Error("Invalid Date");

                    formattedKST = gmtTime.toLocaleString("ko-KR", { timeZone: "Asia/Seoul" }) + " KST";
                } catch (error) {
                    console.error("ì„œë²„ ì‘ë‹µ ì‹œê°„ ë³€í™˜ ì˜¤ë¥˜:", error);
                }
            }

            let titleHtml = "<h3>ì¹­í˜¸</h3>";
            const equippedTitles = titleEquipment?.title_equipment?.filter(title => title.title_equipment_type === "1") || [];

            if (equippedTitles.length > 0) {
                titleHtml += "<ul>";
                equippedTitles.forEach(title => {
                    titleHtml += `<li>${title.title_type_name} - ${title.title_name}</li>`; // title_type_name : ì¥ì°©, íŠ¹ìˆ˜, ê³µì„± ë“±ë“±
                });
                titleHtml += "</ul>";
            } else {
                titleHtml += "<p>ì¥ì°©ëœ ì¹­í˜¸ ì—†ìŒ</p>";
            }

            document.getElementById("result").innerHTML = `
                <h3>ìºë¦­í„° ì •ë³´</h3>
                <p><strong>ë‹‰ë„¤ì„ :</strong> ${data.character_name}</p>
                <p><strong>ì„œë²„ :</strong> ${data.server_name}</p>
                <p><strong>ë ˆë²¨ :</strong> ${data.character_level}</p>
                <p><strong>ì§ì—… :</strong> ${data.character_class_group_name} (${data.character_class_name})</p>
                <p><strong>ìºë¦­í„° ìƒì„±ì¼ :</strong> ${new Date(data.character_date_create).toLocaleDateString()}</p>
                <p><strong>ì„œë²„ ì‘ë‹µ ì‹œê°„ :</strong> ${formattedKST}</p>
                <hr>
                ${titleHtml}
            `;
        }


        //  ì˜ˆì˜ì£¼ì‹œ ë“±ë¡í•¨ìˆ˜
        function addCharacter() {
            const characterName = document.getElementById("trackingCharacterName").value.trim();
            if (!characterName) {
                alert("ìºë¦­í„°ëª…ì„ ì…ë ¥í•˜ì„¸ìš”.");
                return;
            }

            const cardId = `char-${characterName}`;
            if (document.getElementById(cardId)) {
                alert("ì´ë¯¸ ë“±ë¡ëœ ìºë¦­í„°ì…ë‹ˆë‹¤.");
                return;
            }

            const characterCard = document.createElement("div");
            characterCard.className = "character-card";
            characterCard.id = cardId;
            characterCard.innerHTML = `
                <strong>${characterName}</strong>
                <div class="option-group">
                    <label><input type="radio" name="interval-${cardId}" value="10000"> 10ì´ˆ</label>
                    <label><input type="radio" name="interval-${cardId}" value="30000"> 30ì´ˆ</label>
                    <label><input type="radio" name="interval-${cardId}" value="60000"> 1ë¶„</label>
                    <label><input type="radio" name="interval-${cardId}" value="300000"> 5ë¶„</label>
                    <label><input type="radio" name="interval-${cardId}" value="600000"> 10ë¶„</label>
                </div>
                <button onclick="startTracking('${characterName}', '${cardId}')">ì¶”ì í•˜ê¸°</button>
                <button onclick="stopTracking('${characterName}', '${cardId}')">ì¤‘ì§€</button>
                <button onclick="removeCharacter('${cardId}')">ì œê±°</button>
                <div class="result" id="result-${cardId}">ê²°ê³¼ ëŒ€ê¸° ì¤‘...</div>
            `;
            document.getElementById("characterList").appendChild(characterCard);
        }
        // ìºë¦­í„° ë“±ë¡ í•´ì œ
        function removeCharacter(cardId) {
            stopTracking(null, cardId);
            document.getElementById(cardId)?.remove();
        }
        // ì¶”ì  í•¨ìˆ˜
        function startTracking(characterName, cardId) {
            stopTracking(characterName, cardId);
            const selectedInterval = document.querySelector(`input[name="interval-${cardId}"]:checked`);
            if (!selectedInterval) {
                alert("ì¡°íšŒ ì£¼ê¸°ë¥¼ ì„ íƒí•˜ì„¸ìš”.");
                return;
            }
            const intervalTime = parseInt(selectedInterval.value, 10);
            trackingIntervals[cardId] = setInterval(() => fetchCharacterData(characterName, cardId), intervalTime);
            fetchCharacterData(characterName, cardId);
            alert(`${characterName}ì˜ ì •ë³´ë¥¼ ${intervalTime / 1000}ì´ˆë§ˆë‹¤ ì¡°íšŒí•©ë‹ˆë‹¤.`);
        }
        // ì¶”ì  ì¤‘ì§€
        function stopTracking(characterName, cardId) {
            if (trackingIntervals[cardId]) {
                clearInterval(trackingIntervals[cardId]);
                delete trackingIntervals[cardId];
                if (characterName) alert(`${characterName}ì˜ ìë™ ì¡°íšŒë¥¼ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.`);
            }
        }

        async function fetchCharacterData(characterName, cardId) {
            const resultElement = document.getElementById(`result-${cardId}`);
            resultElement.innerText = `ğŸ”„ ${characterName} ì •ë³´ ê°±ì‹  ì¤‘...`;

            try {
                // OCID ì¡°íšŒ
                const ocidRequests = servers.map(server =>
                    fetch(`https://open.api.nexon.com/baramy/v1/id?character_name=${encodeURIComponent(characterName)}&server_name=${encodeURIComponent(server)}`, {
                        method: "GET",
                        headers: { "accept": "application/json", "x-nxopen-api-key": apiKey }
                    }).then(async response => {
                        if (!response.ok) return null;
                        return response.json();
                    }).catch(error => {
                        console.error(`OCID ìš”ì²­ ì‹¤íŒ¨ (${server}):`, error);
                        return null;
                    })
                );

                const ocidResults = await Promise.all(ocidRequests);
                const validResults = ocidResults.filter(data => data && data.ocid);

                if (validResults.length === 0) {
                    resultElement.innerText = "âŒ OCID ì¡°íšŒ ì‹¤íŒ¨: ìºë¦­í„°ëª…ì„ í™•ì¸í•˜ì„¸ìš”.";
                    return;
                }

                // ê°€ì¥ ë†’ì€ ë ˆë²¨ì˜ ìºë¦­í„° ì„ íƒ
                const characterInfos = await Promise.all(validResults.map(async data => {
                    const { characterData, serverDate } = await fetchCharacterInfo(data.ocid);
                    return characterData ? { ...characterData, ocid: data.ocid, serverDate } : null;
                }));

                const validCharacters = characterInfos.filter(char => char);
                if (validCharacters.length === 0) {
                    resultElement.innerText = "âŒ ìºë¦­í„° ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨";
                    return;
                }

                validCharacters.sort((a, b) => a.character_level - b.character_level);
                const highestLevelCharacter = validCharacters.pop();

                // ì¹­í˜¸ ì •ë³´ ì¡°íšŒ
                const titleEquipment = await fetchTitleEquipment(highestLevelCharacter.ocid);

                // ê²°ê³¼ í‘œì‹œ
                displayCharacterTrackingData(highestLevelCharacter, highestLevelCharacter.serverDate, titleEquipment, resultElement);
            } catch (error) {
                console.error("ìºë¦­í„° ì¡°íšŒ ì˜¤ë¥˜:", error);
                resultElement.innerText = "âŒ ë°ì´í„° ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ";
            }
        }

        function displayCharacterTrackingData(data, serverDate, titleEquipment, resultElement) {
            let formattedKST = "ì„œë²„ ì‘ë‹µ ì‹œê°„ ì—†ìŒ";

            if (serverDate) {
                try {
                    const gmtTime = new Date(serverDate);
                    if (isNaN(gmtTime.getTime())) throw new Error("Invalid Date");
                    formattedKST = gmtTime.toLocaleString("ko-KR", { timeZone: "Asia/Seoul" }) + " KST";
                } catch (error) {
                    console.error("ì„œë²„ ì‘ë‹µ ì‹œê°„ ë³€í™˜ ì˜¤ë¥˜:", error);
                }
            }

            let titleHtml = "<h3>ì¹­í˜¸</h3>";
            const equippedTitles = titleEquipment?.title_equipment?.filter(title => title.title_equipment_type === "1") || [];

            if (equippedTitles.length > 0) {
                titleHtml += "<ul>";
                equippedTitles.forEach(title => {
                    titleHtml += `<li>${title.title_type_name} - ${title.title_name}</li>`;
                });
                titleHtml += "</ul>";
            } else {
                titleHtml += "<p>ì¥ì°©ëœ ì¹­í˜¸ ì—†ìŒ</p>";
            }

            resultElement.innerHTML = `
                <h3>ìºë¦­í„° ì •ë³´</h3>
                <p><strong>ë‹‰ë„¤ì„ :</strong> ${data.character_name}</p>
                <p><strong>ì„œë²„ :</strong> ${data.server_name}</p>
                <p><strong>ë ˆë²¨ :</strong> ${data.character_level}</p>
                <p><strong>ì§ì—… :</strong> ${data.character_class_group_name} (${data.character_class_name})</p>
                <p><strong>ìºë¦­í„° ìƒì„±ì¼ :</strong> ${new Date(data.character_date_create).toLocaleDateString()}</p>
                <p><strong>ì„œë²„ ì‘ë‹µ ì‹œê°„ :</strong> ${formattedKST}</p>
                <hr>
                ${titleHtml}
            `;
        }

    </script>
</body>
</html>
